<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>20250427</title>
    <link href="/2025/04/27/20250427/"/>
    <url>/2025/04/27/20250427/</url>
    
    <content type="html"><![CDATA[<h1 id="日记"><a href="#日记" class="headerlink" title="日记"></a>日记</h1><p>两年前，就想着要开始更新博客了，但就更新了几篇就停了。<br>现在想着，作为工程师，不留下点文档，供后人取经，会显着每天都在做无聊的工作、任务。（怎么文采这么烂啊，半天憋不出一个屁来）</p><h1 id="博客内容"><a href="#博客内容" class="headerlink" title="博客内容"></a>博客内容</h1><p>现在想到的博客内容，Linux kernel里面drm框架的实现，以及内核驱动的编写，内核驱动的debug过程。<br>介绍weston的框架，weston的送显逻辑，wayland协议。</p>]]></content>
    
    
    
    <tags>
      
      <tag>display</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cyclitest代码解析</title>
    <link href="/2023/07/27/cyclitest%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/07/27/cyclitest%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="标题：深入理解cyclitest：实时系统延迟测试工具"><a href="#标题：深入理解cyclitest：实时系统延迟测试工具" class="headerlink" title="标题：深入理解cyclitest：实时系统延迟测试工具"></a>标题：深入理解cyclitest：实时系统延迟测试工具</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在实时系统的世界中，延迟是一个关键的性能指标。为了测量和优化这个指标，我们需要使用专门的工具。其中，cyclitest是一个广泛使用的工具，它可以帮助我们测量系统的延迟。然而，对于许多开发者来说，cyclitest的工作原理和使用方法可能并不清楚。因此，我决定写这篇博客，希望能帮助大家更好地理解和使用cyclitest。</p><h2 id="cyclitest的基本原理"><a href="#cyclitest的基本原理" class="headerlink" title="cyclitest的基本原理"></a>cyclitest的基本原理</h2><p>cyclitest的工作原理相当直观。它首先创建多个线程，然后在这些线程中周期性地等待和唤醒。通过测量等待和唤醒之间的时间差，我们就可以得到系统的延迟。cyclitest还会计算最小、最大和平均延迟，并生成延迟的直方图，以便我们更好地理解延迟的分布。</p><h2 id="cyclitest的源代码解析"><a href="#cyclitest的源代码解析" class="headerlink" title="cyclitest的源代码解析"></a>cyclitest的源代码解析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://git.kernel.org/pub/scm/utils/rt-tests/rt-tests.git/tree/src/cyclictest/cyclictest.c<br></code></pre></td></tr></table></figure><p>cyclitest的源代码主要由C语言编写。在main函数中，它首先处理命令行参数，然后创建线程，并在这些线程中进行延迟测量。线程的创建和管理是通过POSIX线程库实现的。延迟的测量是通过POSIX定时器和信号实现的。为了减少延迟的误差，cyclitest还会尽可能地锁定内存，防止其被交换出去。</p><h2 id="如何使用cyclitest"><a href="#如何使用cyclitest" class="headerlink" title="如何使用cyclitest"></a>如何使用cyclitest</h2><p>使用cyclitest相当简单。首先，我们需要编译cyclitest。然后，我们可以通过命令行参数来指定线程的数量、优先级和周期。运行cyclitest后，它会输出每个线程的最小、最大和平均延迟，以及延迟的直方图。我们可以通过这些信息来评估系统的延迟性能。</p><h2 id="cyclitest的局限性和可能的改进"><a href="#cyclitest的局限性和可能的改进" class="headerlink" title="cyclitest的局限性和可能的改进"></a>cyclitest的局限性和可能的改进</h2><p>虽然cyclitest是一个强大的工具，但它也有一些局限性。例如，它可能无法准确测量非常小的延迟，或者它的结果可能受到系统负载和配置的影响。为了解决这些问题，我们可以考虑使用更精确的时间测量方法，或者添加更多的统计功能。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>总的来说，cyclitest是一个非常有用的工具，它可以帮助我们测量和优化实时系统的延迟。我希望这篇博客能帮助你更好地理解和使用cyclitest。如果你有任何问题或建议，欢迎留言讨论。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>cyclitest源代码</li><li>POSIX线程库文档</li><li>POSIX定时器和信号文档</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>cyclitest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gstreamer learning</title>
    <link href="/2023/05/13/gstreamer/"/>
    <url>/2023/05/13/gstreamer/</url>
    
    <content type="html"><![CDATA[<h2 id="极限性能"><a href="#极限性能" class="headerlink" title="极限性能"></a>极限性能</h2><p><code>echo performance | tee $(find /sys |grep governor$) </code># 打开性能模式<br><code>export KMSSINK_DISABLE_VSYNC=1</code> #关闭vsync<br><code>echo 400000000 &gt; sys/kernel/debug/clk/aclk_rkvdec/clk_rate</code> # 提高解码频率<br><code>echo 0x100 &gt; /sys/module/rk_vcodec/parameters/mpp_dev_debug</code>  # 打开mpp解码时间</p><h2 id="sink方式"><a href="#sink方式" class="headerlink" title="sink方式"></a>sink方式</h2><p>可以通过<br>gst-inspect-1.0 kmssink<br>查询sink方式 支持的命令</p><h3 id="xvimagesink"><a href="#xvimagesink" class="headerlink" title="xvimagesink"></a>xvimagesink</h3><p>xvimagesink 需要有硬件加速<br>实现多屏：</p><ul><li><input disabled="" type="checkbox"> <code>gst-play-1.0 --flags=1 --gapless --videosink=&quot;xvimagesink render-rectangle=&lt;0,0,360,210&gt;&quot;  test.mp4 &amp; gst-play-1.0 --flags=1 --gapless --videosink=&quot;xvimagesink render-rectangle=&lt;360,0,360,210&gt;&quot;  test.mp4 </code></li></ul><h3 id="kmssink"><a href="#kmssink" class="headerlink" title="kmssink"></a>kmssink</h3><p>使用AFBC格式播放：<br><code>export GST_MPP_VIDEODEC_DEFAULT_ARM_AFBC=1</code><br><code>GST_DEBUG=fpsdisplaysink:5 gst-play-1.0 GUGUDAN-Wonderland.2160p.UHDTV.H265.ts --flags=3 --use-playbin3 --videosink=&quot;fpsdisplaysink  text-overlay=false video-sink=\&quot;kmssink plane-id=71\&quot; sync=false fps-update-interval=10000 &quot; </code><br>注：plane-id使用对应的cluster层<br>fpsdisplaysink 打开帧率打印<br>text-overlay&#x3D;false 关闭字幕</p><p>普通播放：<br>gst-play-1.0 1.mp4 –flags&#x3D;3 –use-playbin3 –videosink&#x3D;kmssink plane-id&#x3D;65</p><p>gst-play-1.0 oem&#x2F;SampleVideo_1280x720_5mb.mp4 –flags&#x3D;3 –videosink&#x3D;”kmssink connector-id&#x3D;154”<br>指定connector-id</p><p>GST_DEBUG&#x3D;kmssink:5 gst-launch-1.0 v4l2src device&#x3D;&#x2F;dev&#x2F;video20  ! queue ! kmssink</p><p>实现多屏：</p><h3 id="waylandsink"><a href="#waylandsink" class="headerlink" title="waylandsink"></a>waylandsink</h3><p>防止丢帧：<br>    <code>配置文件增加 WAYLANDSINK_SYNC_FRAME</code><br>    <code>export GST_DEBUG=*wayland*:10</code><br>    <code>gst-play-1.0 /test.mp4 --videosink=&quot;waylandsink sync=false&quot; --a udiosink=fakesink 2&gt;&amp;1|grep drop -i     0:00:00.724004250  1064   0x7f8c003060 LOG              waylandsink gstwaylandsink.c:918:gst_wayland_sink_show_frame:&lt;waylandsink0&gt; buffer 0x7fa01b9890 dropped (redraw pending)</code><br>   <code> 检查：源文件：buildroot/output/rockchip_px30_64/build/gst1-plugins-bad-1.14.4/ext/wayland# grep WAYLANDSINK_SYNC_FRAME * gstwaylandsink.c:  if (g_getenv (&quot;WAYLANDSINK_SYNC_FRAME&quot;)) &#123;     库：[root@rk3399:/]# grep WAYLANDSINK_SYNC_FRAME /usr/lib/gstreamer-1.0/libgstwaylandsink.so     WAYLANDSINK_SYNC_FRAME</code><br>实现多屏：</p><h3 id="v4l2src"><a href="#v4l2src" class="headerlink" title="v4l2src"></a>v4l2src</h3><p>gst-launch-1.0 -v v4l2src ! ‘video&#x2F;x-raw,format&#x3D;NV12’ ! mpph264enc ! filesink location&#x3D;”bla.h264”</p><p>gst-launch-1.0 v4l2src ! video&#x2F;x-raw,format&#x3D;NV12,width&#x3D;1920,height&#x3D;1080 ! rkximagesink<br>gst-launch-1.0 v4l2src ! video&#x2F;x-raw,format&#x3D;RGB3,width&#x3D;3840,height&#x3D;2160 ! rkximagesink</p><p>gst-launch-1.0 v4l2src device&#x3D;&#x2F;dev&#x2F;video17 ! video&#x2F;x-raw,format&#x3D;RGB3,width&#x3D;1920, height&#x3D;1080 ! rkximagesink</p><p>gst-launch-1.0 v4l2src device&#x3D;&#x2F;dev&#x2F;video20 ! queue ! kmssink </p><h3 id="零零碎碎"><a href="#零零碎碎" class="headerlink" title="零零碎碎"></a>零零碎碎</h3><p>videoscale是硬件加速，videocrop是软件。较新的gstreamer-rockchip的解码插件支持硬件crop和缩放，比如：<br>gst-launch-1.0 videotestsrc ! mpph264enc ! h264parse ! mppvideodec crop-rectangle&#x3D;’&lt;100,100,100,100&gt;’ width&#x3D;400 height&#x3D;400 ! waylandsink处理顺序是先缩放再裁减</p><p>gstreamer里面的crop是可以通过crop meta进行in place处理，即直接传递裁减区域信息给最终sink端，由sink端处理裁减（kmssink的话是设置drm的src显示区域）。但是in place处理也需求videocrop直连sink。此外kmssink也支持直接配置目标显示区域render-rectangle进行硬件缩放，但是会受到高宽比限制。所以也可以：<br>buildroot更新到：<a href="https://github.com/JeffyCN/rockchip_mirrors/commit/e7c6827a78434aac1aadf95d763bfc318c3b8e5c">https://github.com/JeffyCN/rockchip_mirrors/commit/e7c6827a78434aac1aadf95d763bfc318c3b8e5c</a><br>gst-launch-1.0 filesrc location&#x3D;&#x2F;FPS_test_1080p60_L4.2.mkv ! matroskademux ! decodebin ! videocrop top&#x3D;0 bottom&#x3D;0 left&#x3D;0 right&#x3D;960 ! kmssink render-rectangle&#x3D;’&lt;0,0,1920,1080&gt;’ force-aspect-ratio&#x3D;false</p><p>jerkiness一般是指播放抖动（偶尔丢帧），卡顿是laggy，闪烁是blink和flick。</p><p>硬件加速也是存在耗时的，如其他issue回复，产生耗时的plugin前后最好是加上缓冲队列queue进行异步</p><p>确认硬件加速可以通过log开关：<br>export GST_DEBUG&#x3D;videoflip:5,video-converter:5<br>gst-launch-1.0 … ! videoscale ! video&#x2F;x-raw, width&#x3D;500, height&#x3D;500 ! …0:00:02.974151424 13319 0x3f640300 DEBUG video-converter video-converter.c:2862:video_converter_try_rga: converted with RGA</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs prolog">[root@<span class="hljs-symbol">RK356X</span>:/]# <span class="hljs-symbol">GST_DEBUG</span>=mppdec:<span class="hljs-number">5</span> gst-launch<span class="hljs-number">-1.0</span> filesrc location=/test.mp4 ! qtdemux ! h264parse ! mppvideodec crop-rectangle=<span class="hljs-string">&#x27;&lt;0,0,960,1080&gt;&#x27;</span> width=<span class="hljs-number">3840</span> height=<span class="hljs-number">1080</span> ! queue ! kmssink <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>|grep crop<br><span class="hljs-number">0</span>:<span class="hljs-number">00</span>:<span class="hljs-number">01.271583086</span>   <span class="hljs-number">778</span>     <span class="hljs-number">0x3e9ebde0</span> <span class="hljs-symbol">DEBUG</span>                 mppdec gstmppdec.c:<span class="hljs-number">688</span>:gst_mpp_dec_get_gst_buffer:&lt;mppvideodec0&gt; cropping &lt;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">960</span>,<span class="hljs-number">1080</span>&gt; within &lt;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3840</span>,<span class="hljs-number">1080</span>&gt;<br><br>[root@<span class="hljs-symbol">RK356X</span>:/]# tail <span class="hljs-number">-10</span> /sys/kernel/debug/dri/<span class="hljs-number">0</span>/summary<br>        win_id: <span class="hljs-number">3</span><br>        format: <span class="hljs-symbol">NV12</span> little-endian (<span class="hljs-number">0x3231564e</span>) <span class="hljs-symbol">SDR</span>[<span class="hljs-number">0</span>] color_space[<span class="hljs-number">0</span>] glb_alpha[<span class="hljs-number">0xff</span><br>]<br>        rotate: xmirror: <span class="hljs-number">0</span> ymirror: <span class="hljs-number">0</span> rotate_90: <span class="hljs-number">0</span> rotate_270: <span class="hljs-number">0</span><br>        csc: y2r[<span class="hljs-number">1</span>] r2y[<span class="hljs-number">0</span>] csc mode[<span class="hljs-number">1</span>]<br>        zpos: <span class="hljs-number">3</span><br>        src: pos[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] rect[<span class="hljs-number">960</span> x <span class="hljs-number">1080</span>] 《--- crop到<span class="hljs-number">960</span><br>        dst: pos[<span class="hljs-number">480</span>, <span class="hljs-number">0</span>] rect[<span class="hljs-number">960</span> x <span class="hljs-number">1080</span>]<br>        buf[<span class="hljs-number">0</span>]: addr: <span class="hljs-number">0x00000000040b1000</span> pitch: <span class="hljs-number">3840</span> offset: <span class="hljs-number">0</span> 《--- <span class="hljs-number">3840</span><br>        buf[<span class="hljs-number">1</span>]: addr: <span class="hljs-number">0x00000000040b1000</span> pitch: <span class="hljs-number">3840</span> offset: <span class="hljs-number">4147200</span><br><span class="hljs-symbol">Video</span> <span class="hljs-symbol">Port1</span>: <span class="hljs-symbol">DISABLED</span><br></code></pre></td></tr></table></figure><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><br>[root@rk3399:/]# <span class="hljs-symbol">GST_DEBUG</span>=mppdec:<span class="hljs-number">5</span> gst-launch<span class="hljs-number">-1.0</span> filesrc location=/test.mp4 !qtdemux ! h264parse ! mppvideodec crop-rectangle=<span class="hljs-string">&#x27;&lt;0,0,960,1080&gt;&#x27;</span> width=<span class="hljs-number">3840</span> height=<span class="hljs-number">1080</span> ! queue ! kmssink <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>|grep crop<br><span class="hljs-number">0</span>:<span class="hljs-number">00</span>:<span class="hljs-number">01.085029657</span>  <span class="hljs-number">1428</span>      <span class="hljs-number">0x2fd6a40</span> <span class="hljs-symbol">DEBUG</span>                 mppdec gstmppdec.c:<span class="hljs-number">678</span>:gst_mpp_dec_get_gst_buffer:&lt;mppvideodec0&gt; cropping &lt;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">960</span>,<span class="hljs-number">1080</span>&gt; within &lt;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3840</span>,<span class="hljs-number">1080</span>&gt;<br>[root@rk3399:/]# cat /sys/kernel/debug/dri/<span class="hljs-number">0</span>/summary<br><span class="hljs-symbol">VOP</span> [ff900000.vop]: <span class="hljs-symbol">ACTIVE</span><br>    <span class="hljs-symbol">Connector</span>: <span class="hljs-symbol">HDMI</span>-<span class="hljs-symbol">A</span><br>        overlay_mode[<span class="hljs-number">0</span>] bus_format[<span class="hljs-number">100</span>a] output_mode[f] color_space[<span class="hljs-number">0</span>]<br>    <span class="hljs-symbol">Display</span> mode: <span class="hljs-number">1920</span>x1080p60<br>        clk[<span class="hljs-number">148500</span>] real_clk[<span class="hljs-number">148500</span>] type[<span class="hljs-number">48</span>] flag[<span class="hljs-number">5</span>]<br>        <span class="hljs-symbol">H</span>: <span class="hljs-number">1920</span> <span class="hljs-number">2008</span> <span class="hljs-number">2052</span> <span class="hljs-number">2200</span><br>        <span class="hljs-symbol">V</span>: <span class="hljs-number">1080</span> <span class="hljs-number">1084</span> <span class="hljs-number">1089</span> <span class="hljs-number">1125</span><br>    win0<span class="hljs-number">-0</span>: <span class="hljs-symbol">ACTIVE</span><br>        format: <span class="hljs-symbol">XR24</span> little-endian (<span class="hljs-number">0x34325258</span>) <span class="hljs-symbol">SDR</span>[<span class="hljs-number">0</span>] color_space[<span class="hljs-number">0</span>] 《----- 主图层<br>        csc: y2r[<span class="hljs-number">0</span>] r2r[<span class="hljs-number">0</span>] r2y[<span class="hljs-number">0</span>] csc mode[<span class="hljs-number">0</span>]<br>        zpos: <span class="hljs-number">0</span><br>        src: pos[<span class="hljs-number">0x0</span>] rect[<span class="hljs-number">1920</span>x1080]<br>        dst: pos[<span class="hljs-number">0x0</span>] rect[<span class="hljs-number">1920</span>x1080]<br>        buf[<span class="hljs-number">0</span>]: addr: <span class="hljs-number">0x0000000008c2f000</span> pitch: <span class="hljs-number">7680</span> offset: <span class="hljs-number">0</span><br>    win1<span class="hljs-number">-0</span>: <span class="hljs-symbol">ACTIVE</span><br>        format: <span class="hljs-symbol">NV12</span> little-endian (<span class="hljs-number">0x3231564e</span>) <span class="hljs-symbol">SDR</span>[<span class="hljs-number">0</span>] color_space[<span class="hljs-number">0</span>] 《----- 视频图层<br>        csc: y2r[<span class="hljs-number">1</span>] r2r[<span class="hljs-number">0</span>] r2y[<span class="hljs-number">0</span>] csc mode[<span class="hljs-number">1</span>]<br>        zpos: <span class="hljs-number">1</span><br>        src: pos[<span class="hljs-number">0x0</span>] rect[<span class="hljs-number">960</span>x1080]              《---裁减到<span class="hljs-number">960</span>x1080<br>        dst: pos[<span class="hljs-number">480</span>x0] rect[<span class="hljs-number">960</span>x1080]           《-----显示到<span class="hljs-number">480</span>,<span class="hljs-number">0</span><br>        buf[<span class="hljs-number">0</span>]: addr: <span class="hljs-number">0x000000007e774000</span> pitch: <span class="hljs-number">3840</span> offset: <span class="hljs-number">0</span> 《---- 原图是缩放到<span class="hljs-number">3840</span>宽<br>        buf[<span class="hljs-number">1</span>]: addr: <span class="hljs-number">0x000000007e774000</span> pitch: <span class="hljs-number">3840</span> offset: <span class="hljs-number">4147200</span><br></code></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>参考文档：<br>博主文章 <a href="http://blog.iotwrt.com/media/2017/11/17/gstreamer-study/">http://blog.iotwrt.com/media/2017/11/17/gstreamer-study/</a><br>官网 <a href="https://gstreamer.freedesktop.org/documentation/opengl/?gi-language=c">https://gstreamer.freedesktop.org/documentation/opengl/?gi-language=c</a><br>gstreamer官网教程学习 <a href="https://blog.csdn.net/u010168781/article/details/105750991">https://blog.csdn.net/u010168781/article/details/105750991</a><br>下载地址 <code>git clone https://gitlab.freedesktop.org/gstreamer/gstreamer.git</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>video gstreamer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lcdc</title>
    <link href="/2023/03/08/Lcdc/"/>
    <url>/2023/03/08/Lcdc/</url>
    
    <content type="html"><![CDATA[<h2 id="Lcdc"><a href="#Lcdc" class="headerlink" title="Lcdc"></a>Lcdc</h2><p>数字视频的基本概念源自于模拟视频。对于模拟视频我们可以这样理解：视频可以分解为若干个基本视点（像素），每个像素都有独立的色彩信息，在屏幕上依次将 这些点用电子枪按照行和列打出来，就形成了一幅完整画面，连续的打出画面，利用人眼的延迟特点就可以“显示”动态的图像了。</p><p>水平消隐：电子枪从左到右画出象素，它每次只能画一条扫描线，画下一条之前要先回到左边并做好画下一条扫描线的准备，这之间有一段时间叫做水平消隐（HBlank）。</p><p>垂直消隐：在画完全部256条扫描线之后它又回到屏幕左上角准备下一次画屏幕（帧），这之间的一段时间就是垂直消隐（VBlank）。电子枪就是在不断的走‘之’字形。</p><pre><code class="hljs">行同步（HSYNC）：行同步就是让电子枪控制器知道下面要开始新的一行像素场同步（VSYNC：  场同步就是告诉电子枪控制器下面要开始新的画面数据使能（DE）： 在数据使能区是有效的色彩数据，不在使能范围内的都显示黑色。前肩（Front Porch）/后肩 （Back Porch） ：行同步或场同步信号发出后，视频数据不能立即使能，要留出电子枪回扫的时间。以行扫描为例，从HSYNC结束到DE开始的区间成为行扫描的后肩（绿色区域），从DE结束到HSYNC开始称为前肩（紫色区域）。同样对于场扫面也可以由类似的定义。</code></pre><p>Pixel clock：像素时脉(Pixel clock)指的是用来划分进来的影像水平线里的个别画素， Pixel clock 会将每一条水平线分成取样的样本，越高频率的 Pixel clock，每条扫瞄线会有越多的样本画素。<br>　 HFP: Horizon front porch</p><p>　 HBP: Horizon back porch</p><pre><code class="hljs">VFP: Vertical front porchVBP: Vertical back porch</code></pre><p>　 HDP： Horizon display period</p><pre><code class="hljs">VDP:  Vertical display period</code></pre><p>HTP &#x3D; HSYNC + HDP + HFP + HBP</p><p>VTR &#x3D; VSYNC + VDP + VFP + VBP</p><p>f dot _ clk &#x3D; pixel clock<br>f dot _ clk &#x3D; f v * VTR * HTP<br>f v &#x3D; vertical frequency  (这个是频率，平时见到的很多时候是60HZ)</p><p>pixel clock &#x3D; ()<br>制式          总扫描线       图像区域扫描线       水平总象素       图像区域水平象素       采样频率<br>1080I&#x2F;60Hz       1125       1080                      2200             1920            74.25MHz<br>1080I&#x2F;50Hz       1125       1080                      2640             1920            74.25MHz<br>720P&#x2F;60Hz       750         720                       1650             1280            74.25MHz<br>720P&#x2F;50Hz       750         720                       1980             1280            74.25MHz</p><p>带宽：视频带宽代表显示器显示能力的一个综合指标，指每秒钟所扫描的图素个数，即单位时间内每条扫描线上显示的频点数总和，在模拟视频中以MHz为单位，图1的视频模拟带宽计算如下：，</p><p>Analog BandWidth&#x3D;1650<em>750</em>60&#x3D;74.25MHz 含义为每个时钟要传输74.25M个模拟视频数据。所以720p60 的pclk为74.25Mhz,同理1080P60的P CLOCK为148.5MHz</p><p>但是在数字视频中由于每个像素都是由3种不同的颜色来表示，每种颜色右由一定数量的比特来传输，因此通常会用bps来表示数字带宽，如果图1中使用了RGB传输，每种颜色用1个字节来输出，那么该视频的数字带宽为：<br>Digital BandWidth&#x3D; 模拟带宽<em>8bit</em>3&#x3D;1.782Gbps 含义为每秒要传输1.782G个比特数据</p><h2 id="DSI-Clock"><a href="#DSI-Clock" class="headerlink" title="DSI Clock"></a>DSI Clock</h2><p>目前主流的lcd都是使用mipi总线，涉及到的一些clock在这里整理一下：</p><p>H-total &#x3D; HorizontalActive + HorizontalFrontPorch + HorizontalBackPorch + HorizontalSyncPulse + HorizontalSyncSkew</p><p>V-total &#x3D; VerticalActive + VerticalFrontPorch + VerticalBackPorch + VerticalSyncPulse + VerticalSyncSkew</p><p>Total pixel &#x3D; H-total * V-total * 60(Hz通常都是这个，当然可以变).</p><p>Bitclk &#x3D; Total pixel * bpp(byte) *8&#x2F;lane number(有几路mipi data lane).</p><p>Byteclk &#x3D; bitclk&#x2F;8</p><p>Dsipclk(Dsi pixel clock) &#x3D; (Byteclk * lane number)&#x2F;bpp(byte) &#x3D; Total pixel * 8</p><p>Byteclk &#x3D; pclk * pixel depth &#x2F; lane number</p>]]></content>
    
    
    
    <tags>
      
      <tag>display</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开篇语</title>
    <link href="/2023/02/10/%E5%BC%80%E7%AF%87%E8%AF%AD/"/>
    <url>/2023/02/10/%E5%BC%80%E7%AF%87%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="写blog的意义"><a href="#写blog的意义" class="headerlink" title="写blog的意义"></a>写blog的意义</h2><p>1.希望自己的知识能够帮助到更多的人<br>2.为自己的工作赋予意义</p><h2 id="鼓励"><a href="#鼓励" class="headerlink" title="鼓励"></a>鼓励</h2><p>1.如果觉得我博客对你有帮助，博客质量不错的话。可以打赏噢。你的支持就是我更新的动力。<br>2.打赏时，可以备注信息。我会将你添加至打赏列表里。</p>]]></content>
    
    
    
    <tags>
      
      <tag>stay strong</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/01/30/hello-world/"/>
    <url>/2023/01/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
